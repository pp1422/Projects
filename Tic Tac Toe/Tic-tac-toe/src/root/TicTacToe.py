import random

# Move specifies the move in board with x and y coordinate and score 
class Move:
    def __init__(self,x,y,score):
        self.x=x
        self.y=y
        self.score=score

# Board is the main Tic Tac Toe game class which has 2 dimensional 3 * 3 Matrix game
# AI moves are generated by using Alpha beta Pruning in MiniMax algorithm
class Board:
# 3 * 3 Tic tac toe game matrix
    game = [[0 for x in xrange(3)] for x in xrange(3)]
    # keeps track of total number of moves played so far
    total = 0
    
# This function calculates Human move
    def human_play(self):
        
#    Take x and y coordinates of Matrix ( where x ranges from [0,2] and y ranges from [0,2])
        x = raw_input("Enter x coordinate for your move ")
        y = raw_input("Enter y coordinate for your move ")
    
#    Validate  x and y coordinates for spaces
        if(x.strip()=="" or y.strip()==""):
            print "Invalid x and y coordinates"
            self.human_play()
            return
            
        x = int(x)
        y = int(y)
         
#    Validate x and y coordinates
        if (not (x > -1 and x < 3) ):
            print "wrong x coordinate, it must be in range [0,2]"
            self.human_play()
        elif (not (y > -1 and y < 3) ):    
            print "wrong y coordinate, it must be in range [0,2]"
            self.human_play()
        else:    
#    Validate if position is already occupied
            if (self.game[x][y]==0):
#            Make player move at given position if it is valid
                self.game[x][y]=-1;
                self.total = self.total + 1
#            check if Game is finished after making user makes his move
                score = self.gameFinished()
                
                self.print_board()
                
#            check if human won: human wins if score is -1
                if (score == -1):
                    print "Congrats Champ, You beat AI..."
#            check if board is full and there is a Draw
                elif (self.total==9):
                    print "Game Draw: Yuppie game draw"
#             if the Game is not finished prompt for AI turn
                else: 
                    print "AI's turn"
                    print ""
                    self.ai_play()       
#        If given Position is already occupied, prompt user to play again
            else: 
                print 'Place already occupied. Please enter again'
                self.human_play()
            
            
    def ai_play(self):
        
#    Calculate next move of AI agent using MinMax algorithm with alpha beta pruning
#    Arguments: Turn = true for AI and false for Human
#               alpha = -2 , beta = 2 initially
        move = self.chooseNextMove(True,-2,2)
        
#    if no move is generated check if AI has won or Game is draw
        if(move.x == -1):
            if (move.score == 1):
                print "Hard Luck.. AI won"
            elif (move.score == 0):
                print "Game draw"
        else:
#        Make the calculated move
            self.game[move.x][move.y] = 1
            self.total = self.total + 1
#        check if Game is finished, i.e whether AI has won or there is a draw
            score = self.gameFinished()
            
            self.print_board()
            
#        score is 1 if AI wins
            if (score == 1):
                print "Hard Luck, AI won"
#        score is 0 is there is a draw
            elif (self.total==9):
                print "Game Draw: Yuppie game draw"
#         Prompt for Human turn if Game has not finished
            else: 
                self.human_play()            
        
#    Initialize the Game Board to initial value
    def init_game(self):
        for i in range(3):
            for j in range(3):
                self.game[i][j] = 0
                     
# Print the board       
    def print_board(self):
        for i in range(3):
            for j in range(3):        
                if (self.game[i][j] == -1):
                    print "| 0 ",
                elif (self.game[i][j] == 0): 
                    print "|   ",
                else: print '| X ',    
            print "|"
        print ""   
             
#    
    def chooseNextMove(self,turn,alpha,beta):
#    Initialize the move to some dummy move
        move = Move(-1,-1,0)
        
#    check if either user or AI has won, so that Game matrix can be scored 
#    score = 1 if AI is suppose to win
#    score = -1 if user is suppose to win
#    score = 0 if there is a draw, there will be a draw if board is full
        score = self.gameFinished()
        
        if (score != 0 or self.total ==9): #self.boardFull(self.game)):
            move.score=score
            return move
        
#    Turn is true if it is AI's turn else turn is false if it is user's turn
#    for AI's turn we assign move score as alpha 
#    for Human's turn we assign move score as beta 
        if (turn == True) :
            move.score = alpha
        else:
            move.score = beta
            
        # calculate next move from all valid moves    
        for i in range(3):
            for j in range(3):
        #  find the unoccupied position to make a move
                if (self.game[i][j] == 0):
                    # Fill Game with 1 for AI's turn and with -1 for Human's turn
                    if (turn == True):
                        self.game[i][j] = 1
                    else: self.game[i][j] = -1
                    self.total = self.total + 1
                    # calculate score lower down using 
                    reply = self.chooseNextMove(not turn,alpha,beta)
                    
                    # undo the move so that we can try other moves to maximise score
                    self.game[i][j] = 0
                    self.total = self.total - 1
                    
                    # For AI's turn choose maximum Alpha
                    if (turn == True and reply.score > move.score):
                        move.score = reply.score
                        move.x = i
                        move.y = j
                        alpha = reply.score
                        
                    # For AI' turn choose Minimum value of beta   
                    elif (turn == False and reply.score < move.score):    
                        move.score = reply.score
                        move.x = i
                        move.y = j
                        beta = reply.score
                    
                    # if for any level beta is <= alpha then we need to Prune this State and we do not
                    # need to explore further since we already obtained better move beforehand     
                    if (beta <= alpha):
                        return move
                    
        return move
    
    
# Check if game is finished    
    def gameFinished(self):           
        
        # check for horizontal grid, if all three consecutive blocks are same 
        for i in range(3):
            if(self.game[i][0] == self.game[i][1] and self.game[i][0] == self.game[i][2]):
                return self.game[i][0]
            
        # check for Vertical columns, if consecutive vertical blocks are same        
        for i in range(3):
            if(self.game[0][i] == self.game[1][i] and self.game[0][i] == self.game[2][i]):
                return self.game[0][i]
            
        # Check for diagonals   
        if (self.game[1][1] == self.game[0][0] and self.game[1][1] == self.game[2][2]):
            return self.game[1][1]   
        
        # Check for diagonals
        if (self.game[1][1] == self.game[0][2] and self.game[1][1] == self.game[2][0]):
            return self.game[1][1]
        
        return 0;

def main():
    
# initialize the game    
    game = Board();

# choose turn randomly       
    turn = random.randint(0,1)

    game.init_game() 
       
# if turn =0 then it is Human's turn       
    if (turn==0):
        game.human_play()
# if turn = 1 then it is AI's turn        
    elif (turn==1):
        game.ai_play()
      
# Main function         
main()